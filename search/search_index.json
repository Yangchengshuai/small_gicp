{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"small_gicp","text":""},{"location":"index.html#documentation","title":"Documentation","text":"<ul> <li>C++</li> <li>Python</li> </ul>"},{"location":"paper.html","title":"small_gicp: Efficient and parallel algorithms for point cloud registration","text":"<p>\\def\\CC{{C\\nolinebreak[4]\\hspace{-.05em}\\raisebox{.4ex}{\\tiny\\bf ++}}}</p>","tags":["C++","Python","Point cloud registration"]},{"location":"paper.html#summary","title":"Summary","text":"<p>Point cloud registration is a task of aligning two point clouds measured by 3D ranging sensors, for example, LiDARs and range cameras. Iterative point cloud registration, also known as fine registration or local registration, iteratively refines the transformation between point clouds starting from an initial guess. Each iteration involves a proximity-based point correspondence search and the minimization of the distance between corresponding points, continuing until convergence. Iterative closest point (ICP) and its variants, such as Generalized ICP, are representative iterative point cloud registration algorithms. They are widely used in applications like autonomous vehicle localization [@Kim], place recognition [@Wang], and object classification [@Izadinia]. Since these applications often require real-time or near-real-time processing, speed is a critical factor in point cloud registration routines.</p> <p>small_gicp provides efficient and parallel algorithms to create an extremely fast point cloud registration pipeline. It offers parallel implementations of  downsampling, nearest neighbor search, local feature extraction, and registration to accelerate the entire process. small_gicp is implemented as a header-only \\CC library with minimal dependencies to offer efficiency, portability, and customizability.</p>","tags":["C++","Python","Point cloud registration"]},{"location":"paper.html#statement-of-need","title":"Statement of need","text":"<p>There are several point cloud processing libraries, and PCL [@Rusu], Open3D [@Zhou], libpointmatcher [@Pomerleau] are commonly used in real-time applications owing to their performant implementations. Although they offer numerous functionalities, including those required for point cloud registration, they present several challenges for practical applications and scientific research.</p> <p>Processing speed: A typical point cloud registration pipeline includes processes such as downsampling, nearest neighbor search (e.g., KdTree construction), local feature estimation, and registration error minimization. PCL and Open3D support multi-threading only for parts of these processes (feature estimation and registration error minimization), with the remaining single-threaded parts often limiting the overall processing speed. Additionally, the multi-thread implementations in these libraries can have significant overheads, reducing scalability to many-core CPUs. These issues make it difficult to meet real-time processing requirements, especially on low-specification CPUs. It is also difficult to fully utilize the computational power  of modern high-end CPUs.</p> <p>Customizability: Customizing the internal workings (e.g., replacing the registration cost function or changing the correspondence search method) of existing implementations is challenging due to hard-coded processes. This poses a significant hurdle for research and development, where testing new cost functions and search algorithms is essential.</p> <p>small_gicp: To address these issues and accelerate the development of point cloud registration-related systems, we designed small_gicp with the following features:</p> <ul> <li> <p>Fully parallelized point cloud preprocessing and registration algorithms with minimal overhead,   offering up to 2x speed gain in single-threaded scenarios and better scalability in multi-core   environments.</p> </li> <li> <p>A modular and customizable framework using \\CC templates, allowing easy customization of the   algorithm's internal workings while maintaining efficiency.</p> </li> <li> <p>A header-only \\CC library implementation for easy integration into user projects, with Python bindings   provided for collaborative use with other libraries (e.g., Open3D).</p> </li> </ul>","tags":["C++","Python","Point cloud registration"]},{"location":"paper.html#functionalities","title":"Functionalities","text":"<p>small_gicp implements several preprocessing algorithms related to point cloud registration, and ICP variant algorithms (point-to-point ICP, point-to-plane ICP, and Generalized ICP based on distribution-to-distribution correspondence).</p> <ul> <li>Downsampling<ul> <li>Voxelgrid sampling</li> <li>Random sampling</li> </ul> </li> <li>Nearest neighbor search and point accumulation structures<ul> <li>KdTree</li> <li>Linear iVox (supports incremental points insertion and LRU-cache-based voxel deletion) [@Bai]</li> <li>Gaussian voxelmap (supports incremental points insertion and LRU-cache-based voxel deletion) [@Koide]</li> </ul> </li> <li>Registration error functions<ul> <li>Point-to-point ICP error [@Zhang]</li> <li>Point-to-plane ICP error</li> <li>Generalized ICP error [@Segal]</li> <li>Robust kernels</li> </ul> </li> <li>Least squares optimizers<ul> <li>GaussNewton optimizer</li> <li>LevenbergMarquardt optimizer</li> </ul> </li> </ul>","tags":["C++","Python","Point cloud registration"]},{"location":"paper.html#benchmark-results","title":"Benchmark results","text":"<ul> <li>Single-threaded and multi-threaded (6 threads) <code>small_gicp::voxelgrid_sampling</code> are approximately 1.3x and 3.2x faster than <code>pcl::VoxelGrid</code>, respectively.</li> <li>Multi-threaded construction of <code>small_gicp::KdTree</code> can be up to 6x faster than that of <code>nanoflann</code>.</li> <li>Single-threaded <code>small_gicp::GICP</code> is about 2.4x faster than <code>pcl::GICP</code>, with the multi-threaded version showing better scalability.</li> </ul> <p>More details can be found at \\url{https://github.com/koide3/small_gicp/blob/master/BENCHMARK.md}.</p>","tags":["C++","Python","Point cloud registration"]},{"location":"paper.html#future-work","title":"Future work","text":"<p>The efficiency of nearest neighbor search significantly impacts the overall performance of point cloud registration. While small_gicp currently offers efficient and parallel implementations of KdTree and voxelmap, which are general and useful in many situations, there are other nearest neighbor search methods that can be more efficient under mild assumptions about the point cloud measurement model (e.g., projective search [@Serafin]). We plan to implement these alternative neighbor search algorithms to further enhance the speed of the point cloud registration process. The design of small_gicp, where nearest neighbor search and pose optimization are decoupled, facilitates the easy integration of these new search algorithms.</p>","tags":["C++","Python","Point cloud registration"]},{"location":"paper.html#acknowledgements","title":"Acknowledgements","text":"<p>This work was supported in part by JSPS KAKENHI Grant Number 23K16979.</p>","tags":["C++","Python","Point cloud registration"]},{"location":"paper.html#references","title":"References","text":"","tags":["C++","Python","Point cloud registration"]}]}